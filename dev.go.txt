package weque

func DevCmds(c *cli.Cmd) {
	c.Command("lock", "", func(c *cli.Cmd) {
		var (
			key   = c.String(cli.StringArg{Name: "KEY"})
			count = c.Int(cli.IntArg{Name: "COUNT", Value: 3})
		)
		c.Spec = "KEY [COUNT]"
		c.Action = func() {
			l, err := consul.Client.LockKey(*key)
			if err != nil {
				log.Fatalf("%v", err)
			}

			sigc := make(chan os.Signal, 1)
			signal.Notify(sigc, os.Interrupt)
			go func() {
				select {
				case _ = <-sigc:
					l.Unlock()
				}
			}()

			ch := make(chan struct{}) // Stop attempting to lcok before acquiring the lock.
			fmt.Printf("%v\tTry to lock\n", time.Now().UnixNano())
			c, err := l.Lock(ch)
			if err != nil {
				log.Fatalf("%v", err)
			}

			go func() {
				fmt.Printf("%v\tStart to count down: %v\n", time.Now().UnixNano(), *count)
				for i := 0; i < *count; i++ {
					time.Sleep(1 * time.Second)
					fmt.Printf("%v\n", i+1)
				}
				l.Unlock()
			}()

			fmt.Printf("%v\n", <-c)
		}
	})

	c.Command("producer", "", func(c *cli.Cmd) {
		var (
			key = c.String(cli.StringArg{Name: "KEY"})
		)
		c.Spec = "KEY"
		c.Action = func() {
			l, err := consul.Client.LockKey(*key)
			if err != nil {
				log.Fatalf("%v", err)
			}

			queue := make(chan int, 1)

			go func() {
				for {
					fmt.Printf("%v:\t%v\n", time.Now().UnixNano(), <-queue)
				}
			}()

			for i := 0; i < 1000*1000; i++ {
				_, err := l.Lock(nil)
				if err != nil {
					log.Fatalf("%v", err)
				}

				queue <- i

				l.Unlock()
			}
		}
	})

	c.Command("key", "", func(c *cli.Cmd) {
		var (
			ssid = c.String(cli.StringArg{Name: "SESSION_ID"})
			val  = c.String(cli.StringArg{Name: "VALUE"})
		)
		c.Spec = "SESSION_ID VALUE"
		c.Action = func() {
			kv := consul.Client.KV()
			_, err := kv.Put(&api.KVPair{
				Key:     "hi/foo/bar",
				Value:   []byte(*val),
				Session: *ssid,
			}, nil)
			if err != nil {
				log.Fatalf("%v", err)
			}
		}
	})
}
